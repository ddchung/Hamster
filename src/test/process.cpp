// Hamster process tests

#include <process/base_thread.hpp>
#include <process/riscv_rv32i_thread.hpp>
#include <memory/memory_space.hpp>
#include <platform/platform.hpp>
#include <cassert>

void test_process()
{
    // Test RISC-V RV32I Thread
    Hamster::MemorySpace mem_space;
    int i;

    // Compiled C program
    unsigned char prog[] =
    {
        0x93, 0x07, 0x10, 0x00, 0x93, 0x88, 0x07, 0x00, 
        0x73, 0x00, 0x00, 0x00, 0x93, 0x07, 0x05, 0x00, 
        0x13, 0x85, 0x07, 0x00, 0x67, 0x80, 0x00, 0x00, 
        0x93, 0x07, 0x05, 0x00, 0x93, 0x88, 0x07, 0x00, 
        0x73, 0x00, 0x00, 0x00, 0x93, 0x07, 0x05, 0x00, 
        0x13, 0x85, 0x07, 0x00, 0x67, 0x80, 0x00, 0x00, 
        0x93, 0x07, 0x05, 0x00, 0x93, 0x88, 0x07, 0x00, 
        0x13, 0x85, 0x05, 0x00, 0x73, 0x00, 0x00, 0x00, 
        0x93, 0x07, 0x05, 0x00, 0x13, 0x85, 0x07, 0x00, 
        0x67, 0x80, 0x00, 0x00, 0x93, 0x07, 0x05, 0x00, 
        0x13, 0x87, 0x05, 0x00, 0x93, 0x88, 0x07, 0x00, 
        0x13, 0x05, 0x07, 0x00, 0x93, 0x05, 0x06, 0x00, 
        0x73, 0x00, 0x00, 0x00, 0x93, 0x07, 0x05, 0x00, 
        0x13, 0x85, 0x07, 0x00, 0x67, 0x80, 0x00, 0x00, 
        0x67, 0x80, 0x00, 0x00, 0x13, 0x01, 0x01, 0xff, 
        0x23, 0x26, 0x11, 0x00, 0xef, 0xf0, 0x5f, 0xf8, 
        0x13, 0x07, 0x05, 0x00, 0x93, 0x07, 0x00, 0x00, 
        0x93, 0x88, 0x07, 0x00, 0x13, 0x05, 0x07, 0x00, 
        0x73, 0x00, 0x00, 0x00, 0x93, 0x07, 0x05, 0x00, 
        0x83, 0x20, 0xc1, 0x00, 0x13, 0x01, 0x01, 0x01, 
        0x67, 0x80, 0x00, 0x00, 
    };

    // Allocate pages
    for (uint32_t addr = Hamster::MemorySpace::get_page_start(0x10000); addr <= 0x10000 + sizeof(prog); addr += HAMSTER_PAGE_SIZE)
    {
        i = mem_space.allocate_page(addr);
        assert(i >= 0);
    }
    
    assert(i >= 0);
    i = mem_space.memcpy(0x10094, prog, sizeof(prog));
    assert(i >= 0);

    // Make thread

    Hamster::RV32Thread thread(mem_space);

    // Set start address
    i = thread.set_start_addr(0x10108);
    assert(i == 0);

    // Tick 14 times, as it should complete in 14 instructions
    uint64_t exit_code = 0;
    for (int j = 0; j < 14; ++j)
    {
        i = thread.tick();
        assert(i >= 0);

        if (i == 2)
        {
            auto syscall = thread.get_syscall();
            assert(syscall.syscall_num == 1 || syscall.syscall_num == 0);
            if (syscall.syscall_num == 1)
            {
                // Return a value
                thread.set_syscall_ret(1234);
            }
            else if (syscall.syscall_num == 0)
            {
                // check that we didn't exit yet
                assert(exit_code == 0);

                exit_code = syscall.arg1;
                // don't return...
            }
        }
    }

    // The value that we gave eariler
    assert(exit_code == 1234);
}